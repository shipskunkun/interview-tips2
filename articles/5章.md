## 5-1 virtual dom


vdom  80%依赖diff算法

<b>vdom是什么?</b>

	在前端中，对dom直接修改操作是昂贵的，效率是低下的，
	我们用js对象模拟dom结构，把dom变化的对比,放在js层来做，提高重绘性能
	
	尝试自己写一个vdom的例子

dom:  

![img](https://github.com/shipskunkun/interview-tips2/blob/master/images/2.png)



vdom:


![img](https://github.com/shipskunkun/interview-tips2/blob/master/images/3.png)


## 5-4 jQuery是如何实现 render的

例如表格，每次重新添加 html, HTML 和 data 混合在一起，效率低下


![img](https://github.com/shipskunkun/interview-tips2/blob/master/images/4.png)





## 5-7~ 5-11 snabbdom

随着 React Vue 等框架的流行，Virtual DOM 也越来越火，snabbdom 是其中一种实现，而且 Vue 2.x 版本的 Virtual DOM 部分也是基于 snabbdom 进行修改的。snabbdom 这个库核心代码只有 200 多行，非常适合想要深入了解 Virtual DOM 实现的读者阅读。如果您没听说过 snabbdom，可以先看看官方文档。



diff算法步骤

	1. 用js对象来描述dom树结构，然后用这个js对象来创建一棵真正的dom树，插入到文档中
	2. 当状态更新时,将新的js对象和旧的js对象进行比较，得到两个对象之间的差异
	3. 将差异应用到真正的 dom 上

	
snabbdom 主要的两个函数：

1. h(type, data, children)，返回 Virtual DOM 树。   

		h(‘<标签名>’, {…属性…}, […子元素…])
		h(‘<标签名>’, {…属性…}, ‘….’)  
2.  patch(oldVnode, newVnode)，比较新旧 Virtual DOM 树并更新。

		patch(container, vnode) 
		patch(vnode, newVnode) 

   

![img](https://github.com/shipskunkun/interview-tips2/blob/master/images/5.png)




## 5-15 ~ 5-21  diff算法


h 函数的具体实现

```
function createElement(vnode) {
    var tag = vnode.tag  // 'ul'
    var attrs = vnode.attrs || {}
    var children = vnode.children || []
    if (!tag) {
        return null
    }

    // 创建真实的 DOM 元素
    var elem = document.createElement(tag)
    // 属性
    var attrName
    for (attrName in attrs) {
        if (attrs.hasOwnProperty(attrName)) {
            // 给 elem 添加属性
            elem.setAttribute(attrName, attrs[attrName])
        }
    }
    // 子元素
    children.forEach(function (childVnode) {
        // 给 elem 添加子元素
        elem.appendChild(createElement(childVnode))  // 递归
    })

    // 返回真实的 DOM 元素
    return elem
}


```


patch 函数的具体实现


```
function updateChildren(vnode, newVnode) {
    var children = vnode.children || []
    var newChildren = newVnode.children || []

    children.forEach(function (childVnode, index) {
        var newChildVnode = newChildren[index]
        if (childVnode.tag === newChildVnode.tag) {
            // 深层次对比，递归
            updateChildren(childVnode, newChildVnode)
        } else {
            // 替换
            replaceNode(childVnode, newChildVnode)
        }
    })
}

function replaceNode(vnode, newVnode) {
    var elem = vnode.elem  // 真实的 DOM 节点
    var newElem = createElement(newVnode)

    // 替换
}

```


```

// 渲染函数
var vnode
function render(data) {
    var newVnode = h('table', {}, data.map(function (item) {
        var tds = []
        var i
        for (i in item) {
            if (item.hasOwnProperty(i)) {
                tds.push(h('td', {}, item[i] + ''))
            }
        }
        return h('tr', {}, tds)
    }))

    if (vnode) {
        // re-render
        patch(vnode, newVnode)
    } else {
        // 初次渲染
        patch(container, newVnode)
    }

    // 存储当前的 vnode 结果
    vnode = newVnode
}
```



## diff 总结

vdom 中应用 diff 算法是为了找出需要更新的节点  

实现，patch(container, vnode) 和 patch(vnode, newVnode)

核心逻辑，createElement 和 updateChildren


## 参考文章

https://juejin.im/post/5b9200865188255c672e8cfd

review 

element.setAttribute(attributename,attributevalue)