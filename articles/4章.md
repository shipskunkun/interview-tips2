## 4-10 ~ 4-16 介绍ajax defered


Query 1.5 的变化：   
jQuery 1.5 之后，支持 deferred   
慢慢演化成一个标准，这个标准叫promise

![img]()


开放封闭原则：

	对扩展开放，对修改封闭
	
	
## 4.17~ 4.20 promise

串联：

A ——> B 

B 写在A 的then 中


```
var src1 = 'https://www.imooc.com/static/img/index/logo_new.png'
var result1 = loadImg(src1)

var src2 = 'https://img1.mukewang.com/545862fe00017c2602200220-100-100.jpg'
var result2 = loadImg(src2)

result1.then(function (img1) {
    console.log('第一个图片加载完成', img1.width)
    return result2  // 重要！！！
}).then(function (img2) {
    console.log('第二个图片加载完成', img2.width)
}).catch(function (ex) {
    console.log(ex)
})
```


Promise.al 接受一个promise对象的数组
待全部完成之后，统一执行success


```
var src1 = 'https://www.imooc.com/static/img/index/logo_new.png'
var result1 = loadImg(src1)

var src2 = 'https://img1.mukewang.com/545862fe00017c2602200220-100-100.jpg'
var result2 = loadImg(src2)

Promise.all([result1, result2]).then(function (datas) {

    //接受到的datas 是一个数组，依次包含多个promise 返回的内容
    console.log('all', datas[0])
    console.log('all', datas[1])
})
	// 接收一个包含多个promise 对象的数组
	// 只要有一个完成，就执行success
Promise.race([result1, result2]).then(function (data) {

    // data 为最先执行完成的promise 的返回值
    console.log('race', data)
})
```



## 4-24 async-await
	
	
	async/await 是最直接的同步写法	
作用： 同步执行代码
await 后面是一个 promise 对象

	
	const load = async function() {
		const result1 = await loadImg(src1)
		const result2 = await loadImg(src2)
	}



